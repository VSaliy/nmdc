<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><TITLE>recognizing remote socket closure</TITLE></HEAD><BODY><TABLE width="100%" border="1"><TR><TH width="150">Author</TH><TH>Message</TH></TR><TR><TD valign="top" align="left"><B>CrazyGuy<BR></B>Administrator<BR>Full Member<BR> Offline<BR>Posts: 169<BR></TD><TD valign="top" align="left"><table width="100%" border="0"><tr><td valign="middle"><BR></TD><td valign="middle">recognizing remote socket closure<BR>&#171; <B> on:</B> March 08, 2007, 01:03:11 PM &#187;</TD><td align="right" valign="bottom" height="20"></TD></TR></TABLE>Here&#39;&#39;s a problem that bugged me for a very long time and I was finally able to get sorted yesterday (with help of msdn forums [/default/grin.gif])<BR>Remote socket closure, how to detect it, as DC doesn&#39;&#39;t have a protocol message for this and simply closes unannounced<BR>Code:&#39;&#39;in case of working with TcpClients, you will need the first 2 lines<BR>Dim curUser as System.Net.Sockets.TcpClient&#39;&#39;suppose this is our TcpClient, which should already be known<BR>Dim curSocket as System.Net.Sockets.Socket = curUser.Client&#39;&#39;get the underlying socket<BR>&#39;&#39;now comes the trick<BR>Dim bState As Boolean = curSocket.Poll(1, Net.Sockets.SelectMode.SelectRead)<BR>If bState And (curSocket.Available = 0) Then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;connection was dropped<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<BR>Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;connection still alive<BR>End If<BR>or to write it as a whole function<BR>Code:Public Function CheckSocket(ByVal curConnect As System.Net.Sockets.TcpClient)<BR>&nbsp; &nbsp; &nbsp; &nbsp; Try<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim curSocket As System.Net.Sockets.Socket = curConnect.Client<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim bState As Boolean = curSocket.Poll(1, Net.Sockets.SelectMode.SelectRead)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If bState And (curSocket.Available = 0) Then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;connection was dropped<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Return False<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;connection still alive<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Return True<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<BR>&nbsp; &nbsp; &nbsp; &nbsp; Catch ex As Exception<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;you can add error message handling here<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Return False<BR>&nbsp; &nbsp; &nbsp; &nbsp; End Try<BR>&nbsp; &nbsp; End Function<BR>Have fun&nbsp; :)</TD></TR><TR><TD valign="top" align="left"><B>prov<BR></B>Moderator<BR>Newbie<BR> Offline<BR>Posts: 1<BR></TD><TD valign="top" align="left"><table width="100%" border="0"><tr><td valign="middle"><BR></TD><td valign="middle">Re: recognizing remote socket closure<BR>&#171; <B>Reply #1 on:</B> March 10, 2007, 08:33:45 PM &#187;</TD><td align="right" valign="bottom" height="20"></TD></TR></TABLE>Cheers CG, thats pretty useful i&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;ve been after a way to do that for a while.<BR>The alternative is to use asynchronous socket connections, which raise a data arrival event of 0 bytes when remotely disconnected, so in the code handling the socket&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;s dataArrival event you can check if 0 bytes were recieved and treat the socket as disconnected if so. The code is a lot more complex than manually polling for data on sockets/clients, but much faster and more manageable with lots of sockets.<BR>Code probably wont make much sense on it&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;s own, check out the attached projects, especially the demo code, it&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;s nice and clean.<BR>Code:&nbsp; &nbsp; &nbsp; &nbsp; Private Sub onDataArrival(ByVal ar As IAsyncResult)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;IAsyncResult contains a StateObject to pass information about the event, in this case containing imformation about the socket<BR>&nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;data has arrived on.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;This sub is called when data arrives on a socket.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Try<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim obj_SocketState As StateObject = CType(ar.AsyncState, StateObject)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim obj_Socket As Socket = obj_SocketState.WorkSocket<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim sck_Data As String<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim BytesRead As Integer = obj_Socket.EndReceive(ar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If BytesRead &gt; 0 Then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sck_Data = Encoding.ASCII.GetString(obj_SocketState.Buffer, 0, BytesRead)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;convert bytes to string<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RaiseEvent socketDataArrival(m_SocketID, sck_Data)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;tell app data has arrived, pass data and socket id<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj_Socket.BeginReceive(obj_SocketState.Buffer, 0, obj_SocketState.BufferSize, 0, New AsyncCallback _<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AddressOf onDataArrival), obj_SocketState)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;Start waiting for more data on the socket<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RaiseEvent socketsDisconnected(m_socketID)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;0 Bytes read means socket disconnected, tell the app.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Catch e As Exception<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RaiseEvent socketDisconnected(m_SocketID)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End Try<BR>&nbsp; &nbsp; &nbsp; &nbsp; End Sub<BR>Oh, and credit where it&#39;&#39;&#39;&#39;s due, the sockets code is the work of Mercenary44 from here:<BR>http://www.planet-source-code.com/vb/scripts/ShowCode.asp?txtCodeId=2430&amp;lngWId=10 (i got it from somewhere else with a nice explanation of how it works, but i cant find it now.</TD></TR></TABLE></BODY></HTML>