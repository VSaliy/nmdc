<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><TITLE>Lock-To-Key calculation</TITLE></HEAD><BODY><TABLE width="100%" border="1"><TR><TH width="150">Author</TH><TH>Message</TH></TR><TR><TD valign="top" align="left"><B>CrazyGuy<BR></B>Administrator<BR>Full Member<BR> Offline<BR>Posts: 169<BR></TD><TD valign="top" align="left"><table width="100%" border="0"><tr><td valign="middle"><BR></TD><td valign="middle">Lock-To-Key calculation<BR>&#171; <B> on:</B> June 23, 2007, 04:22:42 PM &#187;</TD><td align="right" valign="bottom" height="20"></TD></TR></TABLE><BR>C<BR>Example One<BR>Code:#include &lt;string.h&gt;<BR>#include &lt;stdlib.h&gt;<BR>/* erealloc done by James N. Hart<BR>&nbsp; &nbsp;Abridged version.<BR>&nbsp; &nbsp;INPUT:<BR>&nbsp; &nbsp; &nbsp;void **mem<BR>&nbsp; &nbsp; &nbsp; &nbsp;- should be a pointer to the pointer that you want to allocate or<BR>&nbsp; &nbsp; &nbsp; &nbsp;reallocate memory to.&nbsp; If *mem == NULL (0) then data will be allocated<BR>&nbsp; &nbsp; &nbsp; &nbsp;from scratch.&nbsp; If != NULL then data will be realloc&#039;ed.<BR>&nbsp; &nbsp; &nbsp;int size<BR>&nbsp; &nbsp; &nbsp; &nbsp;- should be the size of the memory you want allocated. *note this<BR>&nbsp; &nbsp; &nbsp; &nbsp;revision doesn&#039;t do any checking for size 0.&nbsp; Results are undefined if<BR>&nbsp; &nbsp; &nbsp; &nbsp;size == 0..<BR>&nbsp; &nbsp; OUTPUT:<BR>&nbsp; &nbsp; &nbsp; void **mem<BR>&nbsp; &nbsp; &nbsp; &nbsp; - assigned with allocated memory.&nbsp; Memory is initialized with all<BR>&nbsp; &nbsp; &nbsp; &nbsp; bits 0.<BR>&nbsp; &nbsp; PURPOSE:<BR>&nbsp; &nbsp; &nbsp; To give one interface for malloc and realloc, to initialized malloc&#039;ed<BR>&nbsp; &nbsp; &nbsp; data, and to do error checking and handling.<BR>&nbsp; &nbsp; ABRIDGED NOTE:<BR>&nbsp; &nbsp; &nbsp; There are comments where you should add your own error handling code.<BR>&nbsp; &nbsp; EXAMPLE:<BR>&nbsp; &nbsp; &nbsp; Create a character array of 35 characters, then resize it to 25.<BR>&nbsp; &nbsp; &nbsp; char *string = 0;&nbsp; erealloc((void **)&amp;string, sizeof(char)*35);<BR>&nbsp; &nbsp; &nbsp; erealloc((void **)&amp;string, sizeof(char)*25);<BR>*/<BR>void erealloc(void **mem, size_t size)<BR>{<BR>&nbsp; &nbsp;int err = 0;<BR>&nbsp; &nbsp;if(!*mem)<BR>&nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; if(!(*mem = malloc(size)))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*You should handle a memory allocation error here */<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(1);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; &nbsp; &nbsp; memset(*mem, 0, size);<BR>&nbsp; &nbsp; &nbsp; &nbsp; return;<BR>&nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp;if(! (*mem = realloc(*mem, size) ) )<BR>&nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; /*You should handle a memory allocation error here */<BR>&nbsp; &nbsp; &nbsp; &nbsp; exit(1);<BR>&nbsp; &nbsp; &nbsp;}<BR>}<BR>/* generateKey done by James N. Hart<BR>&nbsp; &nbsp;INPUT:<BR>&nbsp; &nbsp; &nbsp;unsigned char *lock<BR>&nbsp; &nbsp; &nbsp; &nbsp;- A null terminated character array that contains the lock posted with<BR>&nbsp; &nbsp; &nbsp; &nbsp;$Lock (excluding $Lock= and &#039; PK=*&#039;)<BR>&nbsp; &nbsp; &nbsp;unsigned char **fkey<BR>&nbsp; &nbsp; &nbsp; &nbsp;- a pointer to a previous allocated char *array or a pointer to a<BR>&nbsp; &nbsp; &nbsp; &nbsp;char *array that has been initialized wiht NULL (0).<BR>&nbsp; &nbsp; OUTPUT:<BR>&nbsp; &nbsp; &nbsp; unsigned char **fkey<BR>&nbsp; &nbsp; &nbsp; &nbsp; - assigned a allocated char *array, null terminated that contains<BR>&nbsp; &nbsp; &nbsp; &nbsp; the key.<BR>&nbsp; &nbsp; PURPOSE:<BR>&nbsp; &nbsp; &nbsp; To generate the key from given lock for as specified for the<BR>&nbsp; &nbsp; &nbsp; DC Protocol.<BR>&nbsp; &nbsp; BUGS:<BR>&nbsp; &nbsp; &nbsp; If you want to use this in a real program, you may want to add error<BR>&nbsp; &nbsp; &nbsp; handling to check that the lock is at least 2 characters long. (if not<BR>&nbsp; &nbsp; &nbsp; this code should crash)<BR>&nbsp; &nbsp; EXAMPLE:<BR>&nbsp; &nbsp; &nbsp; char *lock = &quot;IEatHamsters&quot;, *key = 0;<BR>&nbsp; &nbsp; &nbsp; generateKey(lock, &amp;key);<BR>*/<BR>void generateKey(unsigned char *lock, unsigned char **fkey)<BR>{<BR>&nbsp; &nbsp;int count = 0, len = 0, offset = 0;<BR>&nbsp; &nbsp;char *key = 0, *tkey= 0;<BR>&nbsp; &nbsp;/* Get the length of the lock */<BR>&nbsp; &nbsp;len = strlen(lock);<BR>&nbsp; &nbsp;/* Initialize the key memory */<BR>&nbsp; &nbsp;erealloc((void **)&amp;key, sizeof(char)*(len + 1) );<BR>&nbsp; &nbsp;/* assign key[1 .. len - 1] accoarding to lock to key specs */<BR>&nbsp; &nbsp;while(lock[++count])<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[count] = lock[count] ^ lock[count - 1];<BR>&nbsp; &nbsp;/* assign key[0] with the special data */<BR>&nbsp; &nbsp;key[0] = lock[0] ^ lock[len - 1] ^ lock[len - 2] ^ 5;<BR>&nbsp; &nbsp;count = 0;<BR>&nbsp; &nbsp;/* Swap 4 bits of each result in Key at this point */<BR>&nbsp; &nbsp;while(key[count++])<BR>&nbsp; &nbsp; &nbsp;key[count - 1] = ((key[count - 1]&nbsp; &lt;&lt; 4)) | ((key[count - 1] &gt;&gt; 4));<BR>&nbsp; &nbsp;count = 0;<BR>&nbsp; &nbsp;/* tkey stands for Temp Key, it is needed to write out the encoded key */<BR>&nbsp; &nbsp;erealloc((void **)fkey, sizeof(char)*(len + 1));<BR>&nbsp; &nbsp;tkey = *fkey;<BR>&nbsp; &nbsp;while(key[count++])<BR>&nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; /* If a byte has any of the following values in the case statement it needs<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to be encoded in the format /%DCNxxx%/ where xxx is the ascii value of<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the character */<BR>&nbsp; &nbsp; &nbsp; &nbsp; switch(key[count - 1])<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 0:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 5:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case&nbsp; 36:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 96:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 124:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 126:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;erealloc((void **)&amp;tkey, sizeof(char)*(len + offset + 11));<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprintf(&amp;tkey[count - 1 + offset], &quot;/%%DCN%.3d%%/&quot;, key[count - 1]);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* offset let&#039;s us keep track of where we are in tkey in comparison to<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.&nbsp; Every time we encode a character we have a diffrence of 9 more<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; characters offseted in tkey in relation to key<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offset += 9;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* We don&#039;t need to encode this character */<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tkey[count - 1 + offset] = key[count - 1];<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp;/* Give our string its ending null */<BR>&nbsp; &nbsp;tkey[len + offset] = 0;<BR>&nbsp; &nbsp;/* Assign memory to fkey */<BR>&nbsp; &nbsp;*fkey = tkey;<BR>&nbsp; &nbsp;/* Free key */<BR>&nbsp; &nbsp;free(key);<BR>}<BR>Example Two<BR>Code:#include &lt;stdio.h&gt;<BR>#include &lt;stdlib.h&gt;<BR>#include &lt;string.h&gt;<BR>//From rapsys : http://rapsys.free.fr/ (Under GPL v2 or more license)<BR>/**<BR>&nbsp;* Compute the access key from the $Lock string<BR>&nbsp;* @param lock the lock string<BR>&nbsp;* @return the computed key<BR>&nbsp;*/<BR>char *dc_compute_access_key(char *lock)<BR>{<BR>&nbsp; int count, len, offset;<BR>&nbsp; char *key, *tkey;<BR>&nbsp; unsigned char *fkey;<BR>&nbsp; //Default value<BR>&nbsp; offset = 0;<BR>&nbsp; key = NULL;<BR>&nbsp; tkey = NULL;<BR>&nbsp; // Get the length of the lock<BR>&nbsp; len = strlen(lock);<BR>&nbsp; //Initialize the key memory<BR>&nbsp; key = realloc(key, sizeof(char)*(len + 1) );<BR>&nbsp; if (key == NULL)<BR>&nbsp; {<BR>&nbsp; &nbsp; fprintf(stderr,&quot;Error while realloc key&quot;);<BR>&nbsp; &nbsp; return NULL;<BR>&nbsp; }<BR>&nbsp; //Assign key[1 .. len - 1] accoarding to lock to key specs<BR>&nbsp; count = 1;<BR>&nbsp; while(lock[count])<BR>&nbsp; {<BR>&nbsp; &nbsp; key[count] = lock[count] ^ lock[count - 1];<BR>&nbsp; &nbsp; count++;<BR>&nbsp; }<BR>&nbsp; //Assign key[0] with the special data<BR>&nbsp; key[0] = lock[0] ^ lock[len - 1] ^ lock[len - 2] ^ 5;<BR>&nbsp; count = 0;<BR>&nbsp; //Swap 4 bits of each result in Key at this point<BR>&nbsp; while(key[count])<BR>&nbsp; {<BR>&nbsp; &nbsp; count++;<BR>&nbsp; &nbsp; key[ ((key[count - 1|count - 1] = ((key[count - 1]&nbsp; &lt;&lt; 4)) |] &gt;&gt; 4));<BR>&nbsp; }<BR>&nbsp; count = 0;<BR>&nbsp; /* tkey stands for Temp Key, it is needed to write out the encoded key */<BR>&nbsp; tkey = realloc(tkey, sizeof(char)*(len + 1));<BR>&nbsp; if (tkey == NULL)<BR>&nbsp; {<BR>&nbsp; &nbsp; fprintf(stderr,&quot;Error while realloc tkey&quot;);<BR>&nbsp; &nbsp; return NULL;<BR>&nbsp; }<BR>&nbsp; fkey = (unsigned char*)tkey;<BR>&nbsp; while(key[count++])<BR>&nbsp; {<BR>&nbsp; &nbsp; /* If a byte has any of the following values in the case statement it needs<BR>&nbsp; &nbsp; &nbsp;* to be encoded in the format /%DCNxxx%/ where xxx is the ascii value of<BR>&nbsp; &nbsp; &nbsp;* the character<BR>&nbsp; &nbsp; &nbsp;*/<BR>&nbsp; &nbsp; switch(key[count - 1])<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; case&nbsp; &nbsp;0:<BR>&nbsp; &nbsp; &nbsp; case&nbsp; &nbsp;5:<BR>&nbsp; &nbsp; &nbsp; case&nbsp; 36:<BR>&nbsp; &nbsp; &nbsp; case&nbsp; 96:<BR>&nbsp; &nbsp; &nbsp; case 124:<BR>&nbsp; &nbsp; &nbsp; case 126:<BR>&nbsp; &nbsp; &nbsp; &nbsp; tkey = realloc(tkey, sizeof(char)*(len + offset + 11));<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (tkey == NULL)<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(stderr,&quot;Error while realloc fkey&quot;);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(&amp;tkey[count - 1 + offset], &quot;/%%DCN%.3d%%/&quot;, key[count - 1]);<BR>&nbsp; &nbsp; &nbsp; &nbsp; /* offset let&#039;s us keep track of where we are in tkey in comparison to<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* key.&nbsp; Every time we encode a character we have a diffrence of 9 more<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* characters offseted in tkey in relation to key<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/<BR>&nbsp; &nbsp; &nbsp; &nbsp; offset += 9;<BR>&nbsp; &nbsp; &nbsp; &nbsp; break;<BR>&nbsp; &nbsp; &nbsp; default:<BR>&nbsp; &nbsp; &nbsp; &nbsp; // We don&#039;t need to encode this character<BR>&nbsp; &nbsp; &nbsp; &nbsp; tkey[count - 1 + offset] = key[count - 1];<BR>&nbsp; &nbsp; }<BR>&nbsp; }<BR>&nbsp; //Give our string its ending null<BR>&nbsp; tkey[len + offset] = 0;<BR>&nbsp; //Free key<BR>&nbsp; free(key);<BR>&nbsp; return tkey;<BR>}<BR>int main(int argc, char** argv)<BR>{<BR>&nbsp; printf(&quot;%s&quot;,dc_compute_access_key(&quot;somelockstring&quot;));<BR>&nbsp; return 0;<BR>}<BR>Example Three<BR>Code:#include &lt;stdlib.h&gt;<BR>/* Taken from Dolda Connect -- Licensed under the GPL */<BR>static int reservedchar(unsigned char c)<BR>{<BR>&nbsp; &nbsp; return((c == 0) || (c == 5) || (c == 124) || (c == 96) || (c == 126) || (c == 36));<BR>}<BR>static char *dcmakekey(char *lock)<BR>{<BR>&nbsp; &nbsp; int i, len, offset;<BR>&nbsp; &nbsp; char *buf, *key;<BR>&nbsp; &nbsp; char save;<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp; /* Step 1: Compute key */<BR>&nbsp; &nbsp; buf = malloc(strlen(lock));<BR>&nbsp; &nbsp; save = 5;<BR>&nbsp; &nbsp; len = 0;<BR>&nbsp; &nbsp; for(i = 0; lock[i]; i++) {<BR>&nbsp; &nbsp; &nbsp; &nbsp; buf[i] = lock[i] ^ save;<BR>&nbsp; &nbsp; &nbsp; &nbsp; buf[i] = ((buf[i] &amp; 0x0F) &lt;&lt; 4) | ((buf[i] &amp; 0xF0) &gt;&gt; 4);<BR>&nbsp; &nbsp; &nbsp; &nbsp; save = lock[i];<BR>&nbsp; &nbsp; &nbsp; &nbsp; if((i != 0) &amp;&amp; reservedchar(buf[i]))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += 10;<BR>&nbsp; &nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len++;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; buf[0] ^= buf[i - 1];<BR>&nbsp; &nbsp; if(reservedchar(buf[0]))<BR>&nbsp; &nbsp; &nbsp; &nbsp; len += 10;<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; len++;<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp; /* Step 2: Quote reserved characters */<BR>&nbsp; &nbsp; key = malloc(len + 1);<BR>&nbsp; &nbsp; offset = 0;<BR>&nbsp; &nbsp; for(i = 0; lock[i] != 0; i++) {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if(reservedchar(buf[i]))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset += sprintf(key + offset, &quot;/%%DCN%03i%%/&quot;, buf[i]);<BR>&nbsp; &nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key[offset++] = buf[i];<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; key[offset] = 0;<BR>&nbsp; &nbsp; free(buf);<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp; /* Observe: The caller will have to free the memory */<BR>&nbsp; &nbsp; return(key);<BR>}<BR>Perl<BR>Code:sub lock2key<BR>{<BR>&nbsp; &nbsp;my @lock = split( // , shift );<BR>&nbsp; &nbsp;my $i;<BR>&nbsp; &nbsp;my @key = ();<BR>&nbsp; &nbsp;# convert to ordinal<BR>&nbsp; &nbsp;foreach( @lock ) {<BR>&nbsp; &nbsp; &nbsp; &nbsp;$_ = ord;<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;# calc key[0] with some xor-ing magic<BR>&nbsp; &nbsp;push( @key , $lock[0] ^ 5 );<BR>&nbsp; &nbsp;# calc rest of key with some other xor-ing magic<BR>&nbsp; &nbsp;for( $i = 1 ; $i &lt; @lock ; $i++ ) {<BR>&nbsp; &nbsp; &nbsp; &nbsp;push( @key , ( $lock[$i] ^ $lock[$i - 1] ) );<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;# nibble swapping<BR>&nbsp; &nbsp;for( $i = 0 ; $i &lt; @key ; $i++ ) {<BR>&nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = ( (($key[$i] &lt;&lt; 4) &amp; 240) | ( ($key[$i] &gt;&gt; 4) &amp; 15 )) &amp; 0xff;<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;#temp[0] = (u_int8_t)(temp[0] ^ temp[aLock.length()-1]);<BR>&nbsp; &nbsp;$key[0] = $key[0] ^ $key[ @key - 1 ];<BR>&nbsp; &nbsp;# escape some<BR>&nbsp; &nbsp;foreach( @key ) {<BR>&nbsp; &nbsp; &nbsp; &nbsp;if ( $_ == 0 || $_ == 5 || $_ == 36 || $_ == 96 || $_ == 124 || $_ == 126 ) {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$_ = sprintf( &#039;/%%DCN%03i%%/&#039; , $_ );<BR>&nbsp; &nbsp; &nbsp; &nbsp;} else {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$_ = chr;<BR>&nbsp; &nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;# done<BR>&nbsp; &nbsp;return join( &quot;&quot; , @key );<BR>}<BR>PHP<BR>Example One<BR>Code://--------------------------------<BR>// Done by [RO]VeNoM<BR>// razvan_stanga@yahoo.com<BR>//--------------------------------<BR>function lock2key($_LOCK) {<BR>&nbsp; &nbsp;$lockLength = strlen ($_LOCK);<BR>&nbsp; &nbsp;$h = ord($_LOCK[0]) ^ ord( $_LOCK[ $lockLength - 1] ) ^ ord( $_LOCK[ $lockLength - 2] ) ^ 5;<BR>&nbsp; &nbsp;echo $h . &quot;&lt;br&gt;&quot;;<BR>&nbsp; &nbsp;while ($h &gt; 255) {$h = $h - 256;}<BR>&nbsp; &nbsp;$h = (($h&lt;&lt;4) &amp; 240) || (($h&gt;&gt;4) &amp; 15);<BR>&nbsp; &nbsp;$a = $h;<BR>&nbsp; &nbsp;if ($a == &#039;126&#039; or // &#039;~&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;124&#039; or // &#039;||&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;96&#039; or&nbsp; // &#039;`&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;36&#039; or&nbsp; // &#039;$&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;5&#039; or&nbsp; &nbsp;// &#039;^E&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;0&#039;)&nbsp; &nbsp; &nbsp;// NUL<BR>&nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp;$LockToKey = &quot;/%DCN&quot;;<BR>&nbsp; &nbsp; &nbsp;if ($a &lt; 100)<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .=&quot;0&quot;;<BR>&nbsp; &nbsp; &nbsp;if ($a &lt; 10)<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .=&quot;0&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= $a; // As a string integer<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= &quot;%/&quot;;<BR>&nbsp; &nbsp;} else {<BR>&nbsp; &nbsp; &nbsp;$LockToKey = chr ($a);&nbsp; // No transformation.<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;for ($j = 1; $j &lt; strlen($_LOCK); $j++) {<BR>&nbsp; &nbsp; &nbsp;$h = ord($_LOCK[$j]) ^ ord($_LOCK[$j-1]);<BR>&nbsp; &nbsp; &nbsp;while ($h &gt; 255) {$h = $h - 256;}<BR>&nbsp; &nbsp; &nbsp;$h = (($h&lt;&lt;4) &amp; 240) || (($h&gt;&gt;4) &amp; 15);<BR>&nbsp; &nbsp; &nbsp;echo $j . &quot; - &quot; . ($h*16) . &quot;&lt;br&gt;&quot;;<BR>&nbsp; &nbsp; &nbsp;$a = $h;<BR>&nbsp; &nbsp; &nbsp;if ($a == &#039;126&#039; or // &#039;~&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;124&#039; or // &#039;||&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;96&#039; or&nbsp; // &#039;`&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;36&#039; or&nbsp; // &#039;$&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;5&#039; or&nbsp; &nbsp;// &#039;^E&#039;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$a == &#039;0&#039;)&nbsp; &nbsp; &nbsp;// NUL<BR>&nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= &quot;/%DCN&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if ($a &lt; 100)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .=&quot;0&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if ($a &lt; 10)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .=&quot;0&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= $a; // As a string integer<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= &quot;%/&quot;;<BR>&nbsp; &nbsp; &nbsp;} else {<BR>&nbsp; &nbsp; &nbsp; &nbsp;$LockToKey .= chr ($a);&nbsp; // No transformation.<BR>&nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;return $LockToKey;<BR>}<BR>Example Two<BR>Code://----------<BR>// owiec at barbara . eu . org [PL]<BR>//----------<BR>function keygen($lock)<BR>{<BR>&nbsp; &nbsp; &nbsp;$len = strlen($lock);<BR>&nbsp; &nbsp; &nbsp;$key = array();<BR>&nbsp; &nbsp; &nbsp;$key[0] = ord($lock[0]) ^ ord($lock[$len-1]) ^ ord($lock[$len-2]) ^ 5;<BR>&nbsp; &nbsp; &nbsp;for ($i = 1; $i &lt; $len; $i++)<BR>&nbsp; &nbsp; &nbsp; &nbsp; $key[$i] = ord($lock[$i]) ^ ord($lock[$i-1]);<BR>&nbsp; &nbsp; &nbsp;for ($i = 0; $i &lt; $len; $i++)<BR>&nbsp; &nbsp; &nbsp; &nbsp; $key[$i] = (($key[$i]&lt;&lt;4) &amp; 240) | (($key[$i]&gt;&gt;4) &amp; 15);<BR>&nbsp; &nbsp; &nbsp;$key = array_map(&#039;chr&#039;,$key);<BR>&nbsp; &nbsp; &nbsp;for($i = 0; $i&lt;$len; $i++)<BR>&nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(0))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN000%/&#039;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(5))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN005%/&#039;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(36))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN036%/&#039;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(96))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN096%/&#039;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(124))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN124%/&#039;;<BR>&nbsp; &nbsp; &nbsp; &nbsp;if( $key[$i] == chr(126))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$key[$i] = &#039;/%DCN126%/&#039;;<BR>&nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp; &nbsp;$key = implode(&#039;&#039;,$key);<BR>&nbsp; &nbsp; &nbsp;return $key;<BR>}<BR>Visual BASIC<BR>Example One<BR>Code:&#039;--------------------------------<BR>&#039; Done by Ofca<BR>&#039; ofca@ofca.pl<BR>&#039;--------------------------------<BR>&#039; Wiki edit by bluebear: Old style VB6 LockToKey; would probably not work with the newer versions of hub software<BR>Function Lock2Key(StrLock As String) As String<BR>&nbsp; &nbsp; Dim TLock2Key As String, TChar As Integer<BR>&nbsp; &nbsp; If Len(StrLock) &lt; 3 Then<BR>&nbsp; &nbsp; &nbsp; Lock2Key = Left$(&quot;BROKENCLIENT&quot;, Len(StrLock))<BR>&nbsp; &nbsp; &nbsp; Exit Function<BR>&nbsp; &nbsp; End If<BR>&nbsp; &nbsp; TLock2Key = Chr$(Asc(Left$(StrLock, 1)) Xor Asc(Right$(StrLock, 1)) Xor Asc(Mid$(StrLock, Len(StrLock) - 1, 1)) Xor 5)<BR>&nbsp; &nbsp; For i = 2 To Len(StrLock)<BR>&nbsp; &nbsp; &nbsp; &nbsp; TLock2Key = TLock2Key &amp; Chr$(Asc(Mid$(StrLock, i, 1)) Xor Asc(Mid$(StrLock, i - 1, 1)))<BR>&nbsp; &nbsp; Next i<BR>&nbsp; &nbsp; For i = 1 To Len(TLock2Key)<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = Asc(Mid$(TLock2Key, i, 1))<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = TChar * 16 + TChar&nbsp; 16 &#039;Swap bits 11110000 -&gt; 00001111<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = TChar Mod 256<BR>&nbsp; &nbsp; &nbsp; &nbsp; If TChar = 0 Or TChar = 5 Or TChar = 36 Or TChar = 96 Or TChar = 124 Or TChar = 126 Then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lock2Key = Lock2Key &amp; &quot;/%DCN&quot; &amp; Right$(&quot;000&quot; &amp; TChar,3) &amp; &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lock2Key = Lock2Key &amp; Chr$(TChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; End If<BR>&nbsp; &nbsp; Next i<BR>End Function<BR>Example Two<BR>Code:&#039;------------------------------------------------<BR>&#039;Function made by Massimiliano (Neo) from Italy -<BR>&#039;------------------------------------------------<BR>&#039; Wiki edit by bluebear: This LockToKey was acutally posted as a vb.net converter wich it&#039;s not.<BR>&#039; I&#039;ve havent tryed this one, but guess it will work for vb6.<BR>&nbsp; &nbsp;Public Function LockToKey(ByVal Lck As String) As String<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim h As Integer, j As Integer, n As Integer<BR>&nbsp; &nbsp; &nbsp; &nbsp;n = 5<BR>&nbsp; &nbsp; &nbsp; &nbsp;h = InStr(1, Lck, &quot; &quot;)<BR>&nbsp; &nbsp; &nbsp; &nbsp;If h Then Lck = Left$(Lck, h - 1)<BR>&nbsp; &nbsp; &nbsp; &nbsp;h = Asc(Lck) Xor Asc(Right$(Lck, 1)) Xor Asc(Right$(Lck, 2)) Xor n<BR>&nbsp; &nbsp; &nbsp; &nbsp;h = (h&nbsp; 16) Xor (h * 16)<BR>&nbsp; &nbsp; &nbsp; &nbsp;Do While h &gt; 255<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = h - 256<BR>&nbsp; &nbsp; &nbsp; &nbsp;Loop<BR>&nbsp; &nbsp; &nbsp; &nbsp;Select Case h<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockToKey = &quot;/%DCN&quot; &amp; Right$(&quot;00&quot; &amp; CStr(h), 3) &amp; &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockToKey = Chr(h)<BR>&nbsp; &nbsp; &nbsp; &nbsp;End Select<BR>&nbsp; &nbsp; &nbsp; &nbsp;For j = 2 To Len(Lck)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = Asc(Mid$(Lck, j, 1)) Xor Asc(Mid$(Lck, j - 1, 1))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = (h&nbsp; 16) Xor (h * 16)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Do While h &gt; 255<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = h - 256<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Loop<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select Case h<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockToKey = LockToKey &amp; &quot;/%DCN&quot; &amp; Right$(&quot;00&quot; &amp; CStr(h), 3) &amp; &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockToKey = LockToKey &amp; Chr(h)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End Select<BR>&nbsp; &nbsp; &nbsp; &nbsp;Next<BR>&nbsp; &nbsp;End Function<BR>Visual BASIC .NET<BR>Code:&nbsp; &nbsp;Public Function LocktoKey(ByVal Lck As String) As String<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;// This LockToKey is for VB.NET<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;// Written by bluebear - http://www.thewildplace.dk/<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;// It uses the .net framework string class instead of the old vb6 style<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;// If this don&#039;t work for you it&#039;s because you use the wrong encoding on inbound/outbound data<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;// Expects lock with &quot;$Lock&quot; and PK in string.<BR>&nbsp; &nbsp; &nbsp; &nbsp;&#039;//<BR>&nbsp; &nbsp; &nbsp; &nbsp;Lck = Lck.Replace(&quot;$Lock &quot;, &quot;&quot;)<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim sKey As String<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim sTmp As String<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim iLen As Byte<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim iChar As Integer<BR>&nbsp; &nbsp; &nbsp; &nbsp;Dim iPos As Integer = Lck.IndexOf(&quot; &quot;, 1)<BR>&nbsp; &nbsp; &nbsp; &nbsp;If CBool(iPos) Then Lck = Lck.Substring(0, iPos)<BR>&nbsp; &nbsp; &nbsp; &nbsp;iChar = Asc(Lck) Xor Asc(Lck.Substring(Lck.Length - 1)) Xor Asc(Lck.Substring(Lck.Length - 2, 1)) Xor 5<BR>&nbsp; &nbsp; &nbsp; &nbsp;iChar = (iChar \ 16) Xor (iChar * 16)<BR>&nbsp; &nbsp; &nbsp; &nbsp;Do While iChar &gt; 255<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iChar = iChar - 256<BR>&nbsp; &nbsp; &nbsp; &nbsp;Loop<BR>&nbsp; &nbsp; &nbsp; &nbsp;Select Case iChar<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sTmp = &quot;00&quot; &amp; CStr(iChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iLen = CByte(sTmp.Length)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If iLen &gt; 3 Then iLen -= CByte(3) Else iLen = 0<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sKey = &quot;/%DCN&quot; &amp; sTmp.Substring(iLen) &amp; &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sKey = Chr(iChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp;End Select<BR>&nbsp; &nbsp; &nbsp; &nbsp;For iPos = 1 To Lck.Length - 1<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iChar = Asc(Lck.Substring(iPos, 1)) Xor Asc(Lck.Substring(iPos - 1, 1))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iChar = (iChar \ 16) Xor (iChar * 16)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Do While iChar &gt; 255<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iChar = iChar - 256<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Loop<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select Case iChar<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sTmp = &quot;00&quot; &amp; CStr(iChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iLen = CByte(sTmp.Length)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If iLen &gt; 3 Then iLen -= CByte(3) Else iLen = 0<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sKey += &quot;/%DCN&quot; &amp; sTmp.Substring(iLen) &amp; &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sKey += Chr(iChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End Select<BR>&nbsp; &nbsp; &nbsp; &nbsp;Next<BR>&nbsp; &nbsp; &nbsp; &nbsp;Return sKey<BR>&nbsp; &nbsp;End Function<BR>REALbasic 5.5<BR>Code:&nbsp; // Add a function:&nbsp; Protected Function Lock2Key(sLock As String) As String<BR>&nbsp; // REALBasic Lock To Key converter<BR>&nbsp; // Written in REALBasic 5.5 Pro by Bluebear<BR>&nbsp; // http://www.thewildplace.dk/<BR>&nbsp; // Rember to use the correct encoding for incoming/outgoing data<BR>&nbsp; Dim Lck As String, key As String<BR>&nbsp; Dim iChar As Integer, iPos As Integer<BR>&nbsp; Lck = Replace(sLock, &quot;$Lock &quot;, &quot;&quot;)<BR>&nbsp; iPos = InStr(1, Lck, &quot; &quot;)<BR>&nbsp; If iPos &gt; 0 Then Lck = Left(Lck, iPos - 1)<BR>&nbsp; // 2005&nbsp; //iChar = Bitwise.BitXor(Asc(Lck), Asc(Right(Lck, 1)), Asc(Right(Lck, 2)), 5)<BR>&nbsp; iChar = Bitwise.BitXor(Bitwise.BitXor(Asc(Lck), Asc(Right(Lck, 1))),Bitwise.BitXor(Asc(Right(Lck, 2)), 5))<BR>&nbsp; iChar = Bitwise.BitXor((iChar / 16), (iChar * 16))<BR>&nbsp; While iChar &gt; 255<BR>&nbsp; &nbsp; iChar = iChar - 256<BR>&nbsp; Wend<BR>&nbsp; Select Case iChar<BR>&nbsp; Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; key = &quot;/%DCN&quot; + Right(&quot;00&quot; + CStr(iChar), 3) + &quot;%/&quot;<BR>&nbsp; Case Else<BR>&nbsp; &nbsp; key = Chr(iChar)<BR>&nbsp; End Select<BR>&nbsp; For iPos=2 To Len(Lck)<BR>&nbsp; &nbsp; iChar = Bitwise.BitXor(Asc(Mid(Lck, iPos, 1)), Asc(Mid(Lck, iPos - 1, 1)))<BR>&nbsp; &nbsp; iChar = Bitwise.BitXor((iChar / 16), (iChar * 16))<BR>&nbsp; &nbsp; While iChar &gt; 255<BR>&nbsp; &nbsp; &nbsp; iChar = iChar - 256<BR>&nbsp; &nbsp; Wend<BR>&nbsp; &nbsp; Select Case iChar<BR>&nbsp; &nbsp; Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; key = key + &quot;/%DCN&quot; + Right(&quot;00&quot; + CStr(iChar), 3) + &quot;%/&quot;<BR>&nbsp; &nbsp; Case Else<BR>&nbsp; &nbsp; &nbsp; key = key + Chr(iChar)<BR>&nbsp; &nbsp; End Select<BR>&nbsp; Next<BR>&nbsp; Return key<BR>REALbasic 2005<BR>Code:&nbsp; // Add as function:&nbsp; &nbsp;Function Lock2Key(sLock As String) As String<BR>&nbsp; // REALBasic Lock To Key converter<BR>&nbsp; // Written in REALBasic 2005 Pro by Bluebear<BR>&nbsp; // http://www.thewildplace.dk/<BR>&nbsp; // Rember to use the correct encoding for incoming/outgoing data<BR>&nbsp; Dim Lck As String, key As String<BR>&nbsp; Dim iChar As Integer, iPos As Integer<BR>&nbsp; Lck = Replace(sLock, &quot;$Lock &quot;, &quot;&quot;)<BR>&nbsp; iPos = InStr(1, Lck, &quot; &quot;)<BR>&nbsp; If iPos &gt; 0 Then Lck = Left(Lck, iPos - 1)<BR>&nbsp; iChar = Bitwise.BitXor(Asc(Lck), Asc(Right(Lck, 1)), Asc(Right(Lck, 2)), 5)<BR>&nbsp; iChar = Bitwise.BitXor((iChar / 16), (iChar * 16))<BR>&nbsp; While iChar &gt; 255<BR>&nbsp; &nbsp; iChar = iChar - 256<BR>&nbsp; Wend<BR>&nbsp; Select Case iChar<BR>&nbsp; Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; key = &quot;/%DCN&quot; + Right(&quot;00&quot; + CStr(iChar), 3) + &quot;%/&quot;<BR>&nbsp; Case Else<BR>&nbsp; &nbsp; key = Chr(iChar)<BR>&nbsp; End Select<BR>&nbsp; For iPos=2 To Len(Lck)<BR>&nbsp; &nbsp; iChar = Bitwise.BitXor(Asc(Mid(Lck, iPos, 1)), Asc(Mid(Lck, iPos - 1, 1)))<BR>&nbsp; &nbsp; iChar = Bitwise.BitXor((iChar / 16), (iChar * 16))<BR>&nbsp; &nbsp; While iChar &gt; 255<BR>&nbsp; &nbsp; &nbsp; iChar = iChar - 256<BR>&nbsp; &nbsp; Wend<BR>&nbsp; &nbsp; Select Case iChar<BR>&nbsp; &nbsp; Case 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; key = key + &quot;/%DCN&quot; + Right(&quot;00&quot; + CStr(iChar), 3) + &quot;%/&quot;<BR>&nbsp; &nbsp; Case Else<BR>&nbsp; &nbsp; &nbsp; key = key + Chr(iChar)<BR>&nbsp; &nbsp; End Select<BR>&nbsp; Next<BR>&nbsp; Return key<BR>Python<BR>Example One<BR>Code:# by Benjamin Bruheim<BR>def lock2key(lock):<BR>&nbsp; &nbsp; &quot;Generates response to $Lock challenge from Direct Connect Servers&quot;<BR>&nbsp; &nbsp; lock = [ord(c) for c in lock]<BR>&nbsp; &nbsp; key = [0]<BR>&nbsp; &nbsp; for n in range(1,len(lock)):<BR>&nbsp; &nbsp; &nbsp; &nbsp; key.append(lock[n]^lock[n-1])<BR>&nbsp; &nbsp; key[0] = lock[0] ^ lock[-1] ^ lock[-2] ^ 5<BR>&nbsp; &nbsp; for n in range(len(lock)):<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[n] = ((key[n] &lt;&lt; 4) | (key[n] &gt;&gt; 4)) &amp; 255<BR>&nbsp; &nbsp; result = &quot;&quot;<BR>&nbsp; &nbsp; for c in key:<BR>&nbsp; &nbsp; &nbsp; &nbsp; if c in [0, 5, 36, 96, 124, 126]:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += &quot;/%%DCN%.3i%%/&quot; % c<BR>&nbsp; &nbsp; &nbsp; &nbsp; else:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += chr(c)<BR>&nbsp; &nbsp; return result<BR>if __name__==&quot;__main__&quot;:<BR>&nbsp; &nbsp; key = lock2key(&quot;T&amp;AUreb/M_2Wtp_lZU)EA_yU_)2[2/_4u:,`L`3\\m:+ctsnyw9@&quot;)<BR>&nbsp; &nbsp; assert key==&quot;\x82&#039;vArqp\xd4&amp;!\xd6V2@\xf23c\xf0\xc7\xc6@\xe1b\xc2\xa0g&quot; \<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ &quot;\xb1\x96\x96\xd1\x07\xb6\x14\xf4a\xc4\xc2\xc25\xf6\x13u\x11&quot; \<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ &quot;\x84qp\xd1q\xe0\xe4\x97&quot;<BR>Example Two<BR>Code:# by Benjamin Bruheim, optimized by Dody Suria Wijaya (25% faster)<BR>import array<BR>def lock2key2(lock):<BR>&nbsp; &nbsp; &quot;Generates response to $Lock challenge from Direct Connect Servers&quot;<BR>&nbsp; &nbsp; lock = array.array(&#039;B&#039;, lock)<BR>&nbsp; &nbsp; ll = len(lock)<BR>&nbsp; &nbsp; key = list(&#039;0&#039;*ll)<BR>&nbsp; &nbsp; for n in xrange(1,ll):<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[n] = lock[n]^lock[n-1]<BR>&nbsp; &nbsp; key[0] = lock[0] ^ lock[-1] ^ lock[-2] ^ 5<BR>&nbsp; &nbsp; for n in xrange(ll):<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[n] = ((key[n] &lt;&lt; 4) | (key[n] &gt;&gt; 4)) &amp; 255<BR>&nbsp; &nbsp; result = &quot;&quot;<BR>&nbsp; &nbsp; for c in key:<BR>&nbsp; &nbsp; &nbsp; &nbsp; if c in (0, 5, 36, 96, 124, 126):<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += &quot;/%%DCN%.3i%%/&quot; % c<BR>&nbsp; &nbsp; &nbsp; &nbsp; else:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += chr(c)<BR>&nbsp; &nbsp; return result<BR>TCL<BR>Code:# by Cez<BR>proc lock2key { lock } {<BR>&nbsp; &nbsp;set key &quot;&quot;<BR>&nbsp; &nbsp;set temp &quot;&quot;<BR>&nbsp; &nbsp;set length [string length $lock]<BR>&nbsp; &nbsp;append temp [asc [expr [chr [string index $lock 0]] ^ [chr [string index $lock [expr $length-1]]] ^ [chr [string index $lock [expr $length-2]]] ^ 5]]<BR>&nbsp; &nbsp;for { set x 1 } { $x&lt;$length } { incr x } {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;append temp [asc [expr [chr [string index $lock $x]] ^ [chr [string index $lock [expr $x-1]]]]]<BR>&nbsp; &nbsp;}<BR>&nbsp; &nbsp;for { set x 0 } { $x&lt;$length } { incr x } {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;append key [asc [expr ([chr [string index $temp $x]] &lt;&lt; 4) &amp; 240 | ([chr [string index $temp $x]] &gt;&gt; 4) &amp; 15]]<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp;regsub -all -- {\0} $key &quot;/%DCN000%/&quot; key<BR>&nbsp; &nbsp;regsub -all -- {\^E} $key &quot;/%DCN005%/&quot; key<BR>&nbsp; &nbsp;regsub -all -- {\$} $key &quot;/%DCN036%/&quot; key<BR>&nbsp; &nbsp;regsub -all -- {\`} $key &quot;/%DCN096%/&quot; key<BR>&nbsp; &nbsp;regsub -all -- {\|} $key &quot;/%DCN124%/&quot; key<BR>&nbsp; &nbsp;regsub -all -- {\~} $key &quot;/%DCN126%/&quot; key<BR>&nbsp; &nbsp;return $key<BR>}<BR>proc asc i {<BR>&nbsp; &nbsp; if { $i&lt;0 || $i&gt;255 } { error &quot;asc:Integer out of range 0-255&quot; }<BR>&nbsp; &nbsp; return [format %c $i ]<BR>}<BR>proc chr { c } {<BR>&nbsp; &nbsp; set v 0<BR>&nbsp; &nbsp; scan $c %c v<BR>&nbsp; &nbsp; return $v<BR>}<BR>Delphi<BR>Example One<BR>Code:// By ParadoxHeart<BR>// Ported from JavaDC&#039;s key generator<BR>// This version requires you to cut off the $Lock and pk parts *before* passing the lock code to LockToKey<BR>// I&#039;ll post a version that deals with those itself when I get around to it. :p<BR>uses<BR>&nbsp; SysUtils, StrUtils;<BR>function LockToKey(const LockCode: String): String;<BR>var<BR>&nbsp; i, j: Integer;<BR>begin<BR>&nbsp; if Length(LockCode) &lt; 3 then<BR>&nbsp; begin<BR>&nbsp; &nbsp; Result:= &#039;ERR_INVALIDLOCK&#039;;<BR>&nbsp; &nbsp; Exit;<BR>&nbsp; end;<BR>&nbsp; for i:= 1 to Length(LockCode) do<BR>&nbsp; begin<BR>&nbsp; &nbsp; j:= Ord(LockCode[i]);<BR>&nbsp; &nbsp; if i = 1 then<BR>&nbsp; &nbsp; &nbsp; j:= j xor 5<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; j:= j xor Ord(LockCode[i - 1]);<BR>&nbsp; &nbsp; j:= j + ((j mod 17) * 15);<BR>&nbsp; &nbsp; while j &gt; 255 do<BR>&nbsp; &nbsp; &nbsp; Dec(j, 255);<BR>&nbsp; &nbsp; Result:= Result + Chr(j);<BR>&nbsp; end;<BR>&nbsp; Result[1]:= Chr(Ord(Result[1]) xor Ord(Result[Length(Result)]));<BR>&nbsp; AnsiReplaceStr(Result, #0, &#039;/%DCN000%/&#039;);<BR>&nbsp; AnsiReplaceStr(Result, #5, &#039;/%DCN005%/&#039;);<BR>&nbsp; AnsiReplaceStr(Result, #36, &#039;/%DCN036%/&#039;);<BR>&nbsp; AnsiReplaceStr(Result, #96, &#039;/%DCN096%/&#039;);<BR>&nbsp; AnsiReplaceStr(Result, #124, &#039;/%DCN124%/&#039;);<BR>&nbsp; AnsiReplaceStr(Result, #126, &#039;/%DCN126%/&#039;);<BR>end;<BR>Example Two<BR>Code://New Delphi Lock2Key ( working perfectly )<BR>&nbsp;public<BR>&nbsp; &nbsp;{ Public declarations }<BR>&nbsp; &nbsp;function Key(iLock: String; magic: byte): String;<BR>&nbsp; &nbsp;function ns(eightbit: byte): byte;<BR>//The above declarations must be placed under the public diclarations<BR>function TF_Dark_Deeds.Key(iLock: String; magic: byte): String;<BR>var tmp,Lock : string;<BR>&nbsp; &nbsp; i : integer;<BR>&nbsp; &nbsp; a,b : byte;<BR>begin<BR>&nbsp;if not (pos(&#039; Pk&#039;,ilock) = 0) then<BR>&nbsp; lock := copy(ilock,1,pos(&#039; Pk&#039;,ilock)-1)<BR>&nbsp;else lock := ilock;<BR>&nbsp;<BR>&nbsp;a := ord(lock[length(lock)-1]);<BR>&nbsp;b := ord(lock[length(lock)]);<BR>&nbsp;tmp := chr(ns(ord(lock[1]) xor a xor b xor magic));<BR>&nbsp;<BR>&nbsp;for i := 2 to length(lock) do<BR>&nbsp;begin<BR>&nbsp; tmp := tmp + chr(ns(ord(lock[i]) xor ord(lock[i-1])));<BR>&nbsp;end;<BR>&nbsp;<BR>&nbsp;for i := 1 to length(tmp) do<BR>&nbsp;begin<BR>&nbsp; case ord(tmp[i]) of<BR>&nbsp; &nbsp;0&nbsp; &nbsp; : result := concat(result,&#039;/%DCN000%/&#039;);<BR>&nbsp; &nbsp;5&nbsp; &nbsp; : result := concat(result,&#039;/%DCN005%/&#039;);<BR>&nbsp; &nbsp;36&nbsp; &nbsp;: result := concat(result,&#039;/%DCN036%/&#039;);<BR>&nbsp; &nbsp;96&nbsp; &nbsp;: result := concat(result,&#039;/%DCN096%/&#039;);<BR>&nbsp; &nbsp;124&nbsp; : result := concat(result,&#039;/%DCN124%/&#039;);<BR>&nbsp; &nbsp;126&nbsp; : result := concat(result,&#039;/%DCN126%/&#039;);<BR>&nbsp; &nbsp;else&nbsp; &nbsp;result := concat(result,tmp[i]);<BR>&nbsp; end;<BR>&nbsp;end;<BR>end;<BR>&nbsp;<BR>function TF_Dark_Deeds.ns(eightbit: byte): byte;<BR>begin<BR>&nbsp;result := (eightbit shl 4) or (eightbit shr 4);<BR>end;<BR>//Use the function like this -&gt; key:=LockToKey(Lock,5); // just put a 5 i don&#039;t know why<BR>//by the way tnx to a friend of mine i posted this function<BR>Delphi.NET<BR>Code:// By jazper jazper@zaboo.net<BR>// Ported ParadoxHearts code(above)<BR>// This function also assumes you have stripped $Lock and remove everything from Pk= onwards<BR>uses<BR>&nbsp; System.Text;<BR>type TBuffArray: Array of byte;<BR>function TDCHub.LockToKey(Data: TBuffArray): &amp;string;<BR>var<BR>&nbsp; i,j,Len: Int32;<BR>&nbsp; Key: TBuffArray;<BR>begin<BR>&nbsp; Len := System.Array(Data).Length;<BR>&nbsp; SetLength(Key,Len);<BR>&nbsp; if Len &lt; 3 then<BR>&nbsp; begin<BR>&nbsp; &nbsp; Result:= &#039;ERR_INVALIDLOCK&#039;;<BR>&nbsp; &nbsp; Exit;<BR>&nbsp; end;<BR>&nbsp; for i:= 0 to Len - 1 do<BR>&nbsp; begin<BR>&nbsp; &nbsp; j:= data[i];<BR>&nbsp; &nbsp; if i = 0 then<BR>&nbsp; &nbsp; &nbsp; j:= j xor 5<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; j:= j xor data[i - 1];<BR>&nbsp; &nbsp; j:= j + ((j mod 17) * 15);<BR>&nbsp; &nbsp; while j &gt; 255 do<BR>&nbsp; &nbsp; &nbsp; Dec(j, 255);<BR>&nbsp; &nbsp; Key[i] := j;<BR>&nbsp; end;<BR>&nbsp; Key[0]:= Key[0] xor Key[Len-1];<BR>&nbsp; //<BR>&nbsp; // Convert to string so we can replace some char&#039;s<BR>&nbsp; Result := Encoding.Default.GetString(Key);<BR>&nbsp; // protocol has unaccepted char&#039;s, we must replace them<BR>&nbsp; Result := Result.Replace(#0,&#039;/%DCN000%/&#039;);<BR>&nbsp; Result := Result.Replace(#5,&#039;/%DCN005%/&#039;);<BR>&nbsp; Result := Result.Replace(#36,&#039;/%DCN036%/&#039;);<BR>&nbsp; Result := Result.Replace(#96,&#039;/%DCN096%/&#039;);<BR>&nbsp; Result := Result.Replace(#124,&#039;/%DCN124%/&#039;);<BR>&nbsp; Result := Result.Replace(#126,&#039;/%DCN126%/&#039;);<BR>end;<BR>BcB<BR>Code://* Powered By m4st3rB [Poland] m4st3b@o2.pl<BR>// This version requires you to cut off the &quot;$Lock&quot; and &quot;Pk=...&quot; parts before decoding the lock code to Key<BR>//key1<BR>LockLen=Lock.Length();<BR>char L1,Ln1,Ln2=Lock[LockLen-2];<BR>L1=Lock[1];<BR>Ln1=Lock[LockLen-1];<BR>Key1=Char(L1)^Char(Ln1)^Char(Ln2)^5;<BR>Key1=((Char(Key1)&lt;&lt;4) &amp; 240 ) | ((Char(Key1)&gt;&gt;4) &amp; 15 );&nbsp; &nbsp;// nibble swap<BR>switch (Key1){<BR>case 0: Key=&quot;/%DCN000%/&quot;;<BR>break;<BR>case 5: Key=&quot;/%DCN005%/&quot;;<BR>break;<BR>case 36: Key=&quot;/%DCN036%/&quot;;<BR>break;<BR>case 96: Key=&quot;/%DCN096%/&quot;;<BR>break;<BR>case 124: Key=&quot;/%DCN124%/&quot;;<BR>break;<BR>case 126: Key=&quot;/%DCN126%/&quot;;<BR>break;<BR>default:&nbsp; Key=Char(Key1);<BR>}<BR>// keyi<BR>for (int i=2;i&lt;LockLen;i++){<BR>L1=Lock[i],Ln1=Lock[i-1];<BR>Keyi=Char(L1)^Char(Ln1);<BR>Keyi=((Char(Keyi)&lt;&lt;4) &amp; 240 ) | ((Char(Keyi)&gt;&gt;4) &amp; 15 ); // nibble swap<BR>switch (Keyi){<BR>case 0: Key=Key+&quot;/%DCN000%/&quot;;<BR>break;<BR>case 5: Key=Key+&quot;/%DCN005%/&quot;;<BR>break;<BR>case 36: Key=Key+&quot;/%DCN036%/&quot;;<BR>break;<BR>case 96: Key=Key+&quot;/%DCN096%/&quot;;<BR>break;<BR>case 124: Key=Key+&quot;/%DCN124%/&quot;;<BR>break;<BR>case 126: Key=Key+&quot;/%DCN126%/&quot;;<BR>break;<BR>default:&nbsp; Key=Key+Char(Keyi);<BR>}<BR>}<BR>Java<BR>Code:/**<BR>&nbsp;* Contributed by dCoy<BR>&nbsp;*/<BR>public static String generateKey(String lockString){<BR>&nbsp; &nbsp; int i = 0;<BR>&nbsp; &nbsp; byte&#91;] lock = null;<BR>&nbsp; &nbsp; byte&#91;] key = null;<BR>&nbsp; &nbsp; lockString = lockString.substring(0,lockString.indexOf(&#039; &#039;));<BR>&nbsp; &nbsp; lockString.trim();<BR>&nbsp; &nbsp; lock = lockString.getBytes();<BR>&nbsp; &nbsp; key = new byte[lock.length];<BR>&nbsp; &nbsp; for(i=1;i&lt;lock.length;i++){<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[i] = (byte)((lock[i] ^ lock[i-1]) &amp; 0xFF);<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; key[0] = (byte)((((lock[0] ^ lock[lock.length-1]) ^ lock[lock.length-2]) ^ 5) &amp; 0xFF);<BR>&nbsp; &nbsp; for(i=0;i&lt;key.length;i++){<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[i] = (byte)((((key[i]&lt;&lt;4) &amp; 0xF0) | ((key[i]&gt;&gt;4) &amp; 0x0F)) &amp; 0xFF);<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; return(dcnEncode(new String(key)));<BR>}<BR>public static String dcnEncode(String string){<BR>&nbsp; &nbsp; char&#91;] replacements = null;<BR>&nbsp; &nbsp; int i = 0;<BR>&nbsp; &nbsp; int index = 0;<BR>&nbsp; &nbsp; replacements = new char&#91;]{0,5,36,96,124,126};<BR>&nbsp; &nbsp; for(i=0;i&lt;replacements.length;i++){<BR>&nbsp; &nbsp; &nbsp; &nbsp; while((index = string.indexOf(replacements[i])) &gt;=0 ){<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string = string.substring(0,index)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;/%DCN&quot;+leadz(replacements[i])+&quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + string.substring(index+1,string.length());<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; return(string);<BR>}<BR>private static String leadz(int nr){<BR>&nbsp; &nbsp; if(nr &lt; 100 &amp;&amp; nr &gt; 10){<BR>&nbsp; &nbsp; &nbsp; &nbsp; return(&quot;0&quot;+nr);<BR>&nbsp; &nbsp; } else if(nr &lt; 10){<BR>&nbsp; &nbsp; &nbsp; &nbsp; return(&quot;00&quot;+nr);<BR>&nbsp; &nbsp; } else{<BR>&nbsp; &nbsp; &nbsp; &nbsp; return(&quot;&quot;+nr);<BR>&nbsp; &nbsp; }<BR>}<BR>C#<BR>Please note that the Strings class used in these two examples are contained inside Microsoft.VisualBasic and does therefore require that you add Microsoft.VisualBasic as a reference and that you add using Microsoft.VisualBasic; to the top of the sourcefile. (This is atleast needed for vs 2005 I can&#039;t confirm if it is needed for older version of the compiler aswell)<BR>Example One<BR>Code:<BR>// By RaptoR franz@digital-wave.de<BR>// This function assumes you have stripped $Lock and remove everything from<BR>//&nbsp; &nbsp;Pk= onwards<BR>// This code also works with yhub&#039;s extended char locks!<BR>// Modified by Andreas Brekken &lt;andreas@abrekken.com&gt; for performance,<BR>//&nbsp; &nbsp;readability, less code<BR>public static string Decode( string aLock )<BR>{<BR>&nbsp; &nbsp; char&#91;] key = new char[aLock.Length];<BR>&nbsp; &nbsp; for (int i = 1; i &lt; aLock.Length; i++)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[i] = Strings.Chr(Strings.Asc(aLock[i])<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ Strings.Asc(aLock[i - 1]));<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; key[0] = Strings.Chr(Strings.Asc(aLock[0])<BR>&nbsp; &nbsp; &nbsp; &nbsp; ^ Strings.Asc(aLock[aLock.Length - 1])<BR>&nbsp; &nbsp; &nbsp; &nbsp; ^ Strings.Asc(aLock[aLock.Length - 2])<BR>&nbsp; &nbsp; &nbsp; &nbsp; ^ 5);<BR>&nbsp; &nbsp; for (int i = 0; i &lt; aLock.Length; i++)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; key[i] = Strings.Chr(<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Strings.Asc(key[i]) &lt;&lt; 4) &amp; 240)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ((Strings.Asc(key[i]) &gt;&gt; 4) &amp; 15));<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; string keyString = &quot;&quot;;<BR>&nbsp; &nbsp; for (int i = 0; i &lt; key.Length; i++)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; int j = Strings.Asc(key[i]);<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (j != (int)key[i])<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key[i] = (char)j;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; &nbsp; &nbsp; keyString += key[i];<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; return escapeChars(keyString);<BR>}<BR>private static string escapeChars( string key )<BR>{<BR>&nbsp; &nbsp; System.Text.StringBuilder builder =<BR>&nbsp; &nbsp; &nbsp; &nbsp; new System.Text.StringBuilder(key.Length);<BR>&nbsp; &nbsp; for (int index=0; index&lt;key.Length; index++)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; int code = (int)key[index];<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (code == 0 || code == 5 || code == 36 || code == 96<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || code == 124 || code == 126)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.AppendFormat(&quot;/%DCN{0:000}%/&quot;, code);<BR>&nbsp; &nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.Append(key[index]);<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; return builder.ToString();<BR>}<BR>Example Two<BR>Code:public string LockToKey(string Lck)<BR>{<BR>&nbsp; /*<BR>&nbsp; &nbsp;* This LockToKey is a direct translation of bluebear&#039;s VB.NET LockToKey<BR>&nbsp; &nbsp;*&nbsp; &nbsp;into CSharp by kepp<BR>&nbsp; &nbsp;* Originally written by bluebear - http://www.thewildplace.dk/<BR>&nbsp; &nbsp;* Csharp translation was broken and fixed by bluebear<BR>&nbsp; &nbsp;* If this don&#039;t work for you it&#039;s because you use the wrong encoding on<BR>&nbsp; &nbsp;*&nbsp; &nbsp;inbound/outbound data (System.Text.Encoding.Default)<BR>&nbsp; &nbsp;*/<BR>&nbsp; /*<BR>&nbsp; &nbsp;* Edited by Carraya (I hate bugs)<BR>&nbsp; &nbsp;*/<BR>&nbsp; Lck = Lck.Replace(&quot;$Lock &quot;,&quot;&quot;);<BR>&nbsp; string sKey;<BR>&nbsp; string sTmp;<BR>&nbsp; byte iLen;<BR>&nbsp; int iChar;<BR>&nbsp; int iPos = Lck.IndexOf(&quot; Pk=&quot;,1);<BR>&nbsp; if (Convert.ToBoolean(iPos))<BR>&nbsp; &nbsp; Lck = Lck.Substring(0,iPos);<BR>&nbsp; iChar = (Strings.Asc(Lck) ^ Strings.Asc(Lck.Substring(Lck.Length - 1)) ^ Strings.Asc(Lck.Substring(Lck.Length - 2, 1)) ^ 5);<BR>&nbsp; iChar = (iChar / 16) ^ (iChar * 16);<BR>&nbsp; while(iChar &gt; 255)<BR>&nbsp; {<BR>&nbsp; &nbsp; iChar = iChar - 256;<BR>&nbsp; }<BR>&nbsp; if ((iChar == 0) || (iChar == 5) || (iChar == 36) || (iChar == 96) || (iChar == 124) || (iChar == 126))<BR>&nbsp; {<BR>&nbsp; &nbsp; sTmp = &quot;00&quot; + iChar.ToString();<BR>&nbsp; &nbsp; iLen = Convert.ToByte(sTmp.Length);<BR>&nbsp; &nbsp; if (iLen &gt; 3)<BR>&nbsp; &nbsp; &nbsp; iLen -= 3;<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; iLen = 0;<BR>&nbsp; &nbsp; sKey = &quot;/%DCN&quot; + sTmp.Substring(iLen) + &quot;%/&quot;;<BR>&nbsp; }<BR>&nbsp; else<BR>&nbsp; {<BR>&nbsp; &nbsp; sKey = Strings.Chr(iChar).ToString();<BR>&nbsp; }<BR>&nbsp; for(iPos = 1; iPos &lt; Lck.Length; iPos++)<BR>&nbsp; {<BR>&nbsp; &nbsp; iChar = Strings.Asc(Lck.Substring(iPos, 1)) ^ Strings.Asc(Lck.Substring(iPos - 1, 1));<BR>&nbsp; &nbsp; iChar = (iChar / 16) ^ (iChar * 16);<BR>&nbsp; &nbsp; while(iChar &gt; 255)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; iChar = iChar - 256;<BR>&nbsp; &nbsp; }&nbsp;<BR>&nbsp; &nbsp; if ((iChar == 0) || (iChar == 5) || (iChar == 36) || (iChar == 96) || (iChar == 124) || (iChar == 126))<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; sTmp = &quot;00&quot; + iChar.ToString();<BR>&nbsp; &nbsp; &nbsp; iLen = Convert.ToByte(sTmp.Length);<BR>&nbsp; &nbsp; &nbsp; if (iLen &gt; 3)<BR>&nbsp; &nbsp; &nbsp; &nbsp; iLen -= 3;<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; iLen = 0;<BR>&nbsp; &nbsp; &nbsp; sKey += &quot;/%DCN&quot; + sTmp.Substring(iLen) + &quot;%/&quot;;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; sKey += Strings.Chr(iChar).ToString();<BR>&nbsp; &nbsp; }<BR>&nbsp; }<BR>&nbsp; return sKey;<BR>}<BR>Example Three<BR>Code:<BR>// In order to work properly, your client should be properly configured for the<BR>// 1252-Windows encoding. Alternatively, you may have to change to byte&#91;] for it<BR>// to pass properly over a socket. Written by Emil MÃ¼ller.<BR>public string LockToKey(string lck)<BR>{<BR>&nbsp; &nbsp; string Key = &quot;&quot;;<BR>&nbsp; &nbsp; for (int i = 0, j; lck.Length &gt; i; i++)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (i == 0) j = lck[0] ^ 5;<BR>&nbsp; &nbsp; &nbsp; &nbsp; else j = lck[i] ^ lck[i - 1];<BR>&nbsp; &nbsp; &nbsp; &nbsp; for (j += ((j % 17) * 15); j &gt; 255; j -= 255) ;<BR>&nbsp; &nbsp; &nbsp; &nbsp; switch (j)<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 0:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 36:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 96:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 124:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 126:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Key += &quot;/%DCN&quot; + ((string)(&quot;00&quot; + j.ToString())).Substring(j.ToString().Length - 1) + &quot;%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Key += (char)j;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; return (char)(Key[0] ^ Key[Key.Length - 1]) + Key.Substring(1);<BR>}<BR>Visual FoxPro 6<BR>Code:* Coded By ZOseZEro @ Latvia<BR>func LockToKey<BR>&nbsp; &nbsp; &nbsp; &nbsp; para pcLock<BR>&nbsp; &nbsp; &nbsp; &nbsp; priv Lock2Key, TLock2Key, TChar, i<BR>&nbsp; &nbsp; &nbsp; &nbsp; Lock2Key=&quot;&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; If Len(pcLock)&lt;3<BR>&nbsp; &nbsp; &nbsp; retu(Left(&quot;BROKENCLIENT&quot;, Len(pcLock)))<BR>&nbsp; &nbsp; EndIf<BR>&nbsp; &nbsp; TLock2Key = Chr(lXor(lXor(lXor(Asc(Left(pcLock, 1)), ;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Asc(Right(pcLock, 1))), ;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Asc(substr(pcLock, Len(pcLock) - 1, 1))), ;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5))<BR>&nbsp; &nbsp; For i = 2 To Len(pcLock)<BR>&nbsp; &nbsp; &nbsp; &nbsp; TLock2Key = TLock2Key + Chr(lXor(Asc(substr(pcLock, i, 1)), ;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Asc(substr(pcLock, i - 1, 1))))<BR>&nbsp; &nbsp; Next<BR>&nbsp; &nbsp; For i = 1 To Len(TLock2Key)<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = Asc(substr(TLock2Key, i, 1))<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = TChar * 16 + int(TChar / 16) &amp;&amp;Swap bits 11110000 -&gt; 00001111<BR>&nbsp; &nbsp; &nbsp; &nbsp; TChar = mod(TChar, 256)<BR>&nbsp; &nbsp; &nbsp; &nbsp; If TChar = 0 Or TChar = 5 Or TChar = 36 Or TChar = 96 Or TChar = 124 Or TChar = 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lock2Key = Lock2Key + &quot;/%DCN&quot; + Right(&quot;000&quot; + alltrim(str(TChar)),3) + &quot;%/&quot;<BR>&nbsp; &nbsp; &nbsp; &nbsp; Else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lock2Key = Lock2Key + Chr(TChar)<BR>&nbsp; &nbsp; &nbsp; &nbsp; EndIf<BR>&nbsp; &nbsp; Next<BR>&nbsp; &nbsp; retu(Lock2Key)<BR>End func<BR>func lXor<BR>&nbsp; &nbsp; &nbsp; &nbsp; para n1,n2<BR>&nbsp; &nbsp; &nbsp; &nbsp; priv x,ret<BR>&nbsp; &nbsp; &nbsp; &nbsp; ret=0<BR>&nbsp; &nbsp; &nbsp; &nbsp; for x=1 to 8<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if mod(n1,2) + mod(n2,2)=1<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret=ret+2^(x-1)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endif<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1=int(n1/2)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n2=int(n2/2)<BR>&nbsp; &nbsp; &nbsp; &nbsp; next<BR>&nbsp; &nbsp; &nbsp; &nbsp; retu (ret)<BR>end func<BR>mIRC 5.91+<BR>Code:; Coded by Mardeg<BR>alias lock2key {<BR>&nbsp;var %gl = $1, %gf = $base($xor($xor($xor($asc($left(%gl,1)),$asc($right(%gl,1))),$asc($left($right(%gl,2),1))),5),10,2,8)<BR>&nbsp;var %gt = $+(/,%,DCN005,%,/,./,%,DCN000,%,/,./,%,DCN036,%,/,./,%,DCN096,%,/,./,%,DCN124,%,/,./,%,DCN126,%,/)<BR>&nbsp;var %gb = 2, %ge = $len(%gl), %gn = 5.0.36.96.124.126, %gk<BR>&nbsp;%gf = $base($+($right(%gf,4),$left(%gf,4)),2,10)<BR>&nbsp;%gf = $iif($findtok(%gn,%gf,1,46),$gettok(%gt,$ifmatch,46),$chr(%gf))<BR>&nbsp;while (%gb &lt;= %ge) {<BR>&nbsp; &nbsp;%gk = $base($xor($asc($mid(%gl,%gb,1)),$asc($mid(%gl,$calc(%gb - 1),1))),10,2,8)<BR>&nbsp; &nbsp;%gk = $base($+($right(%gk,4),$left(%gk,4)),2,10)<BR>&nbsp; &nbsp;%gf = $+(%gf,$iif($findtok(%gn,%gk,1,46),$gettok(%gt,$ifmatch,46),$chr(%gk)))<BR>&nbsp; &nbsp;inc %gb<BR>&nbsp;}<BR>&nbsp;return %gf<BR>}<BR>Lua 5.0+<BR>Code:-- Coded by Mardeg<BR>function bODD(x)<BR>&nbsp; &nbsp; &nbsp; &nbsp;return x ~= math.floor(x / 2) * 2<BR>end<BR>function bitwise(x, y, bw)<BR>&nbsp; &nbsp; &nbsp; &nbsp;local c, p = 0, 1<BR>&nbsp; &nbsp; &nbsp; &nbsp;while x &gt; 0 or y &gt; 0 do<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bw == &quot;xor&quot; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (bODD(x) and not bODD(y)) or (bODD(y) and not bODD(x)) then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = c + p<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elseif bw == &quot;and&quot; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bODD(x) and bODD(y) then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = c + p<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elseif bw == &quot;or&quot; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bODD(x) or bODD(y) then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = c + p<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x = math.floor(x / 2)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y = math.floor(y / 2)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = p * 2<BR>&nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; &nbsp; &nbsp;return c<BR>end<BR>function nibbleswap(bits)<BR>&nbsp;return bitwise(bitwise(bits*(2^4),240,&quot;and&quot;),bitwise(math.floor(bits/(2^4)),15,&quot;and&quot;),&quot;or&quot;)<BR>end<BR>function lock2key(lock)<BR>local key = {}<BR>table.insert(key,bitwise(bitwise(bitwise(string.byte(lock,1),string.byte(lock,-1),&quot;xor&quot;),string.byte(lock,-2),&quot;xor&quot;),5,&quot;xor&quot;))<BR>for i=2,string.len(lock),1 do<BR>table.insert(key,bitwise(string.byte(lock,i),string.byte(lock,i - 1),&quot;xor&quot;))<BR>end<BR>local g = {[&quot;5&quot;]=1,[&quot;0&quot;]=1,[&quot;36&quot;]=1,[&quot;96&quot;]=1,[&quot;124&quot;]=1,[&quot;126&quot;]=1}<BR>for i=1,table.getn(key),1 do<BR>local b = nibbleswap(rawget(key,i))<BR>rawset(key,i,(g[tostring(b)] and string.format(&quot;/%%DCN%03d%%/&quot;,b) or string.char(b)))<BR>end<BR>return table.concat(key)<BR>end<BR>JavaScript 1.5<BR>Code:// Coded by Mardeg<BR>function nibbleswap(bits) {<BR>return ((bits &lt;&lt; 4) &amp; 240) | ((bits &gt;&gt;&gt; 4) &amp; 15);<BR>}<BR>function chr(b) {<BR>return ((&quot;..0.5.36.96.124.126.&quot;).indexOf(&quot;.&quot;+b+&quot;.&quot;)&gt;0)?&quot;/%DCN&quot;+(0).toPrecision(4-b.toString().length).substr(2)+b+&quot;%/&quot;:String.fromCharCode(b);<BR>}<BR>function lock2key(lock) {<BR>var key = chr(nibbleswap(lock.charCodeAt(0) ^ lock.charCodeAt(-1) ^ lock.charCodeAt(-2) ^ 5));<BR>for (var i=1; i&lt;lock.length; i++) {<BR>key += chr(nibbleswap(lock.charCodeAt(i) ^ lock.charCodeAt(i - 1)));<BR>}<BR>return key;<BR>}<BR>ICI<BR>Code:// Coded by Mardeg, tidied up by Andy Newman<BR>static lock2key(lock)<BR>{<BR>f := [func (c)<BR>{<BR>g := [struct<BR>(0) = &quot;/%DCN000%/&quot;,<BR>(5) = &quot;/%DCN005%/&quot;,<BR>(36) = &quot;/%DCN036%/&quot;,<BR>(96) = &quot;/%DCN096%/&quot;,<BR>(124) = &quot;/%DCN124%/&quot;,<BR>(126) = &quot;/%DCN126%/&quot;<BR>];<BR>c = ((c &lt;&lt; 4) &amp; 0xf0) | ((c &gt;&gt; 4) &amp; 15);<BR>b := g[c];<BR>return b == NULL ? tochar(c) : b;<BR>}];<BR>len := nels(lock);<BR>if (len &lt; 3) return &quot;BROKENCLIENT&quot;;<BR>key := array(f(toint(lock[0]) ^ toint(lock[len-1]) ^ toint(lock[len-2]) ^ 5));<BR>for (i := 1; i &lt; len; ++i)<BR>{<BR>push(key, f(toint(lock[i]) ^ toint(lock[i - 1])));<BR>}<BR>return implode(key);<BR>}<BR>Erlang<BR>Code:%% Translated from Python code by Ivan Dubrov<BR>lock_to_key(Lock) -&gt;<BR>&nbsp; &nbsp; [First | Tail] = Lock,<BR>&nbsp; &nbsp; {Key, _} = lists:mapfoldl(fun(Cur, Prev) -&gt; {Cur bxor Prev, Cur} end, First, Tail),<BR>&nbsp; &nbsp; [Lock1, Lock2] = lists:nthtail(length(Lock) - 2, Lock), [Lock0 | _] = Lock,<BR>&nbsp; &nbsp; Key2 = [Lock0 bxor Lock1 bxor Lock2 bxor 5 | Key],<BR>&nbsp; &nbsp; Key3 = lists:map(fun(Val) -&gt; &lt;&lt;Hi:4, Low:4&gt;&gt; = &lt;&lt;Val&gt;&gt;, &lt;&lt;Res&gt;&gt; = &lt;&lt;Low:4, Hi:4&gt;&gt;, Res end, Key2),<BR>&nbsp; &nbsp; Key4 = lists:foldl(fun(Val, AccIn) -&gt;<BR>&nbsp; &nbsp; &nbsp; &nbsp; AccIn ++<BR>&nbsp; &nbsp; &nbsp; &nbsp; if<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val ==&nbsp; &nbsp;0 -&gt; &quot;/%DCN000%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val ==&nbsp; &nbsp;5 -&gt; &quot;/%DCN005%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val ==&nbsp; 36 -&gt; &quot;/%DCN036%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val ==&nbsp; 96 -&gt; &quot;/%DCN096%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val == 124 -&gt; &quot;/%DCN124%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Val == 126 -&gt; &quot;/%DCN126%/&quot;;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; true -&gt; [Val]<BR>&nbsp; &nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp; end, &#91;], Key3),<BR>&nbsp; &nbsp; Key4.<BR>Ruby<BR>Code: # By C Erler with suggestions by Robert Klemme.<BR>&nbsp;# Took the way of combining neighboring characters from the Python code.<BR>&nbsp;<BR>&nbsp;def key(lock)<BR>&nbsp; &nbsp;# We need a String of at least two bytes.<BR>&nbsp; &nbsp;raise TypeError, &quot;cannot convert #{lock.class} into String&quot;, caller unless lock.respond_to? :to_str<BR>&nbsp; &nbsp;lock = lock.to_str<BR>&nbsp; &nbsp;return &#039;&#039; unless lock.length &gt;= 2<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp;# Transform the input bytes.<BR>&nbsp; &nbsp;result = Array.new(lock.length) { |i| lock[i - 1] ^ lock[i] }<BR>&nbsp; &nbsp;result[0] ^= lock[-2] ^ 5<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp;result.map! do |value|<BR>&nbsp; &nbsp; &nbsp;# Rotate each byte by four bits.<BR>&nbsp; &nbsp; &nbsp;value = ((value &lt;&lt; 4) | (value &gt;&gt; 4)) &amp; 0b11111111<BR>&nbsp; &nbsp; &nbsp;<BR>&nbsp; &nbsp; &nbsp;# Put the output in the correct format.<BR>&nbsp; &nbsp; &nbsp;case value<BR>&nbsp; &nbsp; &nbsp; &nbsp;when 0, 5, 36, 96, 124, 126<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#039;/%%DCN%03d%%/&#039; % value<BR>&nbsp; &nbsp; &nbsp; &nbsp;else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value.chr<BR>&nbsp; &nbsp; &nbsp;end<BR>&nbsp; &nbsp;end<BR>&nbsp; &nbsp;<BR>&nbsp; &nbsp;# Combine the parts into the resultant string.<BR>&nbsp; &nbsp;result.join<BR>&nbsp;end<BR></TD></TR></TABLE></BODY></HTML>